<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chapter 2 – A View from Orbit</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 40px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        ul {
            margin-left: 20px;
        }
        code {
            background-color: #f4f4f4;
            padding: 4px 6px;
            border-radius: 4px;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 6px;
        }
        blockquote {
            border-left: 4px solid #3498db;
            padding-left: 10px;
            color: #555;
            margin: 10px 0;
        }
    </style>
</head>
<body>

<h1>Chapter 2 – A View from Orbit</h1>

<p>
This chapter explains <strong>DevOps and Continuous Delivery (CD)</strong> by looking at the
<strong>big picture</strong> first—like viewing Earth from space. Before building or using a
DevOps pipeline, we must understand <strong>how all parts fit together</strong> and
<strong>who is involved</strong>.
</p>

<hr>

<h2>1. What is the DevOps CD Pipeline?</h2>

<p>A <strong>CD pipeline</strong> is the journey your code takes:</p>

<p><strong>From a developer’s laptop → testing → production (real users)</strong></p>

<p>It connects many systems:</p>

<ul>
    <li>Developers</li>
    <li>Code repositories</li>
    <li>Build servers</li>
    <li>Testing environments</li>
    <li>Production servers</li>
    <li>Release managers</li>
</ul>

<p>
Even though each organization looks different,
<strong>most CD pipelines follow a similar flow</strong>.
</p>

<img src = "images/CI-CD_Pipeline.webp" style="max-width:720px; height:auto; display:block;"> 

<hr>

<h2>2. Developers – Where Everything Starts</h2>

<p>Developers write code on their own machines.</p>

<h3>What developers need:</h3>

<ul>
    <li>Programming tools (IDE, compiler, libraries)</li>
    <li>A <strong>development environment</strong> similar to production</li>
    <li>Mock systems (fake payment systems, fake hardware, etc.)</li>
</ul>

<p><strong>Why similar to production?</strong></p>
<p>
If production runs on Linux, developers should also use Linux-like systems.
This avoids “it works on my machine” problems.
</p>

<h3>Common tools:</h3>

<ul>
    <li>Java: JDK + Eclipse</li>
    <li>Python: Virtualenv, Anaconda</li>
    <li>Containers: Docker</li>
    <li>Virtual machines: Vagrant</li>
</ul>

<hr>

<h2>3. Revision Control System (RCS)</h2>

<p>This is the <strong>central place where all code lives</strong>.</p>

<p><strong>Common example:</strong> Git</p>

<h3>What is stored here?</h3>

<ul>
    <li>Application code</li>
    <li>Configuration files</li>
    <li>Infrastructure scripts</li>
</ul>

<h3>Why it is important:</h3>

<ul>
    <li>Keeps history of changes</li>
    <li>Enables teamwork</li>
    <li>Triggers automated builds</li>
</ul>

<p><strong>Think of RCS as the heart of DevOps.</strong></p>

<hr>

<h2>4. Build Server (Continuous Integration – CI)</h2>

<p>A <strong>build server automatically checks your code</strong>.</p>

<h3>What it does:</h3>

<ol>
    <li>Detects new code changes in Git</li>
    <li>Downloads the latest code</li>
    <li>Builds it</li>
    <li>Runs tests</li>
</ol>

<p>This process is called <strong>Continuous Integration (CI)</strong>.</p>

<p><strong>Popular tool:</strong> Jenkins</p>

<p><strong>Goal:</strong> Catch errors <strong>early</strong>, not after deployment.</p>

<hr>

<h2>5. Artifact Repository</h2>

<p>
After code is built, it becomes a <strong>binary file</strong>
(JAR, WAR, RPM, etc.).
</p>

<p>These files are stored in an <strong>artifact repository</strong>.</p>

<h3>Examples:</h3>

<ul>
    <li>Sonatype Nexus</li>
    <li>Amazon S3</li>
</ul>

<h3>Why not store binaries in Git?</h3>

<ul>
    <li>Git is for source code</li>
    <li>Artifact repositories handle versions and large files better</li>
</ul>

<hr>

<h2>6. Package Managers</h2>

<p>Package managers help <strong>install software automatically</strong> on servers.</p>

<h3>Examples:</h3>

<ul>
    <li>Red Hat systems: <code>yum</code>, <code>dnf</code></li>
    <li>Debian systems: <code>apt</code></li>
</ul>

<h3>Benefits:</h3>

<ul>
    <li>Automatic dependency handling</li>
    <li>Easy upgrades</li>
    <li>Consistent installations</li>
</ul>

<p>Example command:</p>

<pre><code>yum install my-app</code></pre>

<hr>

<h2>7. Test Environments</h2>

<ul>
    <li>Software is installed into <strong>test environments</strong></li>
    <li>Automated and manual tests are run</li>
</ul>

<blockquote>
    Test environments should be as close to production as possible
</blockquote>

<p>This helps avoid surprises in production.</p>

<hr>

<h2>8. Staging and Production</h2>

<h3>Staging:</h3>

<ul>
    <li>Final testing environment</li>
    <li>Almost identical to production</li>
</ul>

<h3>Production:</h3>

<ul>
    <li>Real users access this</li>
</ul>

<h3>Blue-Green Deployment:</h3>

<ul>
    <li>Two identical environments</li>
    <li>One is live, the other is updated</li>
    <li>Traffic is switched after testing</li>
</ul>

<h3>Benefits:</h3>

<ul>
    <li>Very safe deployment</li>
    <li>Easy rollback</li>
</ul>

<hr>

<h2>9. Release Management (Human Control)</h2>

<p>
Even with automation, <strong>humans still decide</strong> when software goes live.
</p>

<h3>Reasons:</h3>

<ul>
    <li>Business timing</li>
    <li>Incomplete test automation</li>
    <li>Risk management</li>
</ul>

<p>A <strong>release manager</strong>:</p>

<ul>
    <li>Approves versions</li>
    <li>Controls deployment timing</li>
</ul>

<p>
Automation + human approval = <strong>realistic DevOps</strong>
</p>

<hr>

<h2>10. Scrum, Kanban, and DevOps</h2>

<p>DevOps supports <strong>all Agile methods</strong>:</p>

<ul>
    <li><strong>Scrum</strong> – sprint-based delivery</li>
    <li><strong>Kanban</strong> – continuous delivery</li>
    <li>Even <strong>Waterfall</strong> can use DevOps tools</li>
</ul>

<blockquote>
    DevOps is process-neutral.  
    It works with any development methodology.
</blockquote>

<hr>

<h2>11. Example: One Change Going to Production</h2>

<ol>
    <li>Developer adds a new user role</li>
    <li>Writes tests (TDD)</li>
    <li>Commits code to Git</li>
    <li>Jenkins builds and tests it</li>
    <li>Artifact stored in Nexus</li>
    <li>Installed in test environment using Puppet</li>
    <li>Automated tests run</li>
    <li>QA team approves</li>
    <li>Deployed to staging</li>
    <li>Swapped into production using a load balancer</li>
</ol>

<p>
Even a <strong>small change</strong> touches many systems.
</p>

<hr>

<h2>12. Identifying Bottlenecks</h2>

<h3>Good pipeline:</h3>
<ul>
    <li>Deploys to test servers in about 15 minutes</li>
</ul>

<h3>Bad pipeline:</h3>
<ul>
    <li>Takes days</li>
</ul>

<h3>Common problems:</h3>

<ul>
    <li>Database changes</li>
    <li>Bad test data</li>
    <li>Manual steps</li>
    <li>Too many approvals</li>
    <li>Large monolithic applications</li>
</ul>

<h3>DevOps encourages:</h3>

<ul>
    <li>Small changes</li>
    <li>Automation</li>
    <li>Continuous improvement (Kaizen)</li>
</ul>

<hr>

<h2>13. Key Takeaway (Summary)</h2>

<ul>
    <li>DevOps is about <strong>flow</strong>, not just tools</li>
    <li>CD pipelines connect many systems</li>
    <li>Automation + human control is necessary</li>
    <li>Faster feedback = better software</li>
    <li>Identifying bottlenecks is critical</li>
</ul>

<p>
In the next chapter, the focus shifts to
<strong>how DevOps influences software architecture</strong>
to make delivery faster and safer.
</p>

</body>
</html>


